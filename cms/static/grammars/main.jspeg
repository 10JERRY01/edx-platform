/* null_ is used in JSON parser */
{  
  null_ = new Object(); 
}

start
  = sections:(Image / 
              GeneralResponse / 
              NumericalOrStringResponse / 
              NumericalResponse / 
              MultipleChoice / 
              Paragraph
              )+

/* GeneralResponse */

KeyValueString
  = QuotedString
  / chars:[^: \n]+
    {
      return chars.join("");
    }

KeyValuePair
  = key:KeyValueString _ ':' _ value:KeyValueString
    {
      return {'key': key, 'value': value};
    } 

InlineGeneralResponse
  = CorrectAnswerIdentifier pairs:(' '+ KeyValuePair)+ Linebreak
    {
      ret = {};
      pairs = pairs.map(function (x) { return x[1]; });
      for (var i = 0; i < pairs.length; i++) {
        console.log(pairs);
        if (ret[pairs[i].key] == undefined)
          ret[pairs[i].key] = pairs[i].value;
        else
          throw new SyntaxError("Key " + pairs[i].key + " was used more than once. " );
      }
      return ret;
    }

GeneralResponseValue
  = InlineGeneralResponse / JSONDictionary

GeneralResponse
  = dic:GeneralResponseValue
    {
      if (dic.type == undefined) {
        throw new SyntaxError("Please define 'type' in response. ")
      }
      return dic;
    }

/* Image */

ImageLink
  = QuotedString
  / chars:( (!')' [^\n])+)
    {
      return $.trim(chars.map(function(element) { return element[1]; }).join(""));
    }

ImageTitle
  = chars:( !'(' [^\n\[\]] )+
    {
      return $.trim(chars.map(function(element) { return element[1]; }).join(""));
    }

Image
  = ImageIdentifier title:ImageTitle? _ '(' _ url:ImageLink ')' ' '* Linebreak
    {
      return {'type': 'image', 'url': url, 'title': title};
    }

/* First character in a line as identifier */

ChoiceIdentifier
  = '(' parenthesized:[x ]? ')'
    {
      return parenthesized == 'x';
    }

ImageIdentifier
  = '!'

CorrectAnswerIdentifier
  = '='

/* StringResponse */

StringResponse
  = CorrectAnswerIdentifier _ !'(' value:(QuotedString / Text) Linebreak
    {
      return {'type': 'string', 'answer': $.trim(value)};
    }

NumericalOrStringResponse
  = CorrectAnswerIdentifier _ value:NumericalValue _ tolerance:NumericalTolerance? _ Linebreak
    {
      if (tolerance == "")
        tolerance = "5%"
      return {'type': 'numerical', 'answer': value, 'tolerance': tolerance};
    }
  / StringResponse

/* MultipleChoice */

ChoiceTextLine
  = !ChoiceIdentifier line:Line
    {
      return line;
    }

Choice
  = correct:ChoiceIdentifier lines:(ChoiceTextLine)+
    {
      return {'type': 'choice', 'correct' : correct, 'text': lines.join("")};
    }

MultipleChoice
  = choices:Choice+
    {
      return {'type': 'multiple_choice', 'choices': choices};
    }

/* Paragraph */
LineOrLinebreak
  = Line / Linebreak

ParagraphTextLine
  = !JSONDictionary !ImageIdentifier !ChoiceIdentifier !CorrectAnswerIdentifier line:LineOrLinebreak
    {
      return line;
    }

Paragraph
  = lines:ParagraphTextLine+
    {
      return {'type': 'text', 'text': lines.join("")};
    }

/* Base symbols */

Line
  = text:Text terminator:Linebreak
    {
      return text + '\n';
    }

Text
  = chars:([^\n]+)
    {
      return chars.join("");
    }

_AndLines
  = (' ' / '\n' / '\t')*

_
  = (' ' / '\t')*

Linebreak
  = ('\n')

QuotedString
  = DoubleQuotedString / SingleQuotedString

DoubleQuotedString
  = "\"\"" { return ""; }
  / "\"" str:(!UnescapedDoubleQuote .)* last:UnescapedDoubleQuote {
    return str.map(function(element) { return element[1]; }).join("") + last;
  }

UnescapedDoubleQuote
  = last:[^\\] "\"" {return last;}

SingleQuotedString
  = "''" { return ""; }
  / "'" str:(!UnescapedSingleQuote .)* last:UnescapedSingleQuote {
    return str.map(function(element) { return element[1]; }).join("") + last;
  }

UnescapedSingleQuote
  = last:[^\\] "'" {return last;}

AlphanumericalText
  = chars:[a-zA-Z0-9]+
  {
    return chars.join("");
  }

/* JSON */

/* JSON parser based on the grammar described at http://json.org/. */

JSONDictionary
  = _ o:object { return o; }

object
  = "{" _ "}" _                 { return {};      }
  / "{" _ members:members "}" _ { return members; }

members
  = head:pair tail:("," _ pair)* {
      var result = {};
      result[head[0]] = (head[1] === null_ ? null : head[1]);
      for (var i = 0; i < tail.length; i++) {
        result[tail[i][2][0]] = (tail[i][2][1] === null_ ? null : tail[i][2][1]);
      }
      return result;
    }

pair
  = name:string ":" _ value:value { return [name, value]; }

array
  = "[" _ "]" _                   { return [];       }
  / "[" _ elements:elements "]" _ { return elements; }

elements
  = head:value tail:("," _ value)* {
      var result = [head === null_ ? null : head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][2] === null_ ? null : tail[i][2]);
      }
      return result;
    }

value
  = string
  / number
  / object
  / array
  / "true" _  { return true;   }
  / "false" _ { return false;  }
  / "null" _  { return null_; }

string "string"
  = '"' '"' _             { return "";    }
  / '"' chars:chars '"' _ { return chars; }

chars
  = chars:char+ { return chars.join(""); }

char
  // In the original JSON grammar: "any-Unicode-character-except-"-or-\-or-control-character"
  = [^"\\\0-\x1F\x7f]
  / '\\"'  { return '"';  }
  / "\\\\" { return "\\"; }
  / "\\/"  { return "/";  }
  / "\\b"  { return "\b"; }
  / "\\f"  { return "\f"; }
  / "\\n"  { return "\n"; }
  / "\\r"  { return "\r"; }
  / "\\t"  { return "\t"; }
  / "\\u" h1:hexDigit h2:hexDigit h3:hexDigit h4:hexDigit {
      return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
    }

number "number"
  = int_:int frac:frac exp:exp _ { return parseFloat(int_ + frac + exp); }
  / int_:int frac:frac _         { return parseFloat(int_ + frac);       }
  / int_:int exp:exp _           { return parseFloat(int_ + exp);        }
  / int_:int _                   { return parseFloat(int_);              }

int
  = digit19:digit19 digits:digits     { return digit19 + digits;       }
  / digit:digit
  / "-" digit19:digit19 digits:digits { return "-" + digit19 + digits; }
  / "-" digit:digit                   { return "-" + digit;            }

frac
  = "." digits:digits { return "." + digits; }

exp
  = e:e digits:digits { return e + digits; }

digits
  = digits:digit+ { return digits.join(""); }

e
  = e:[eE] sign:[+-]? { return e + sign; }

digit
  = [0-9]

digit19
  = [1-9]

hexDigit
  = [0-9a-fA-F]

_ "whitespace"
  = whitespace*

// Whitespace is undefined in the original JSON grammar, so I assume a simple
// conventional definition consistent with ECMA-262, 5th ed.
whitespace
  = [ \t\n\r]


/* NumericalResponse */

NumericalToleranceValueType
  = decimal / percentage / integer

NumericalTolerance
  = '+-' _ value:NumericalToleranceValueType _
    {
      return value;
    }

NumericalResponse
  = CorrectAnswerIdentifier _ '(' _ value:NumericalValue _ tolerance:NumericalTolerance? ')' _ Linebreak
    {
      if (tolerance == "")
        tolerance = "5%"
      return {'type': 'numerical', 'answer': value, 'tolerance': tolerance};
    }

NumericalValue
  = additive

/* Mathematical rules */

additive
  = left:multiplicative "+" right:additive { return left + right; }
  / left:multiplicative "-" right:additive { return left - right; }
  / multiplicative

multiplicative
  = left:primary "*" right:multiplicative { return left * right; }
  / left:primary "/" right:multiplicative { return left / right; }
  / primary

primary
  = decimal
  / integer
  / "(" additive:additive ")" { return additive; }

decimal "decimal"
  = sign:[+-]? first:[0-9]* point:'.' last:[0-9]+
    { return parseFloat(sign + first.join("") + point + last.join("")); }

integer "integer"
  = sign:[+-]? digits:[0-9]+ { return parseInt(sign + digits.join(""), 10); }

percentage "percentage"
  = digits:[0-9]+ '%' { return parseInt(digits.join(""), 10) + '%'; }
